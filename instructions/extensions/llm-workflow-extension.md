# LLM/AI Workflow Extension

## Template Generation Guide for LLM/AI Features
**Purpose:** Generate enhanced LLM/AI workflow templates for end-user projects with intelligent pattern detection and clear implementation guidance.

### Design Document Integration
@include orchestration/orchestrator-hooks.md hook="design_document_validation"

**Template Requirement:** This extension ensures end-user projects receive design-first templates specifically tailored for LLM/AI features.

## Intelligent Pattern Detection Templates

### Pattern Detection Logic Template
**Template Output:** `scripts/detect_llm_pattern.py` for end-user projects
```python
#!/usr/bin/env python3
"""
LLM/AI Pattern Detection for PocketFlow Template Selection
Auto-generated by Agent OS + PocketFlow framework
TODO: Customize pattern detection logic for your specific use cases
"""

import re
from typing import List, Dict, Any
from enum import Enum

class PocketFlowPattern(Enum):
    AGENT = "agent"
    WORKFLOW = "workflow" 
    RAG = "rag"
    MAPREDUCE = "mapreduce"
    MULTI_AGENT = "multi_agent"

class PatternDetector:
    """TODO: Customize pattern detection algorithms for your project needs"""
    
    def __init__(self):
        # TODO: Add your custom pattern indicators
        self.pattern_indicators = {
            PocketFlowPattern.AGENT: [
                r"decision\s*making", r"dynamic\s*behavior", r"intelligent\s*agent",
                r"autonomous", r"adaptive", r"reasoning"
            ],
            PocketFlowPattern.WORKFLOW: [
                r"sequential\s*processing", r"pipeline", r"workflow", 
                r"step\s*by\s*step", r"chain", r"process\s*flow"
            ],
            PocketFlowPattern.RAG: [
                r"retrieval", r"knowledge\s*base", r"document\s*search",
                r"context\s*enhanced", r"information\s*retrieval", r"qa\s*system"
            ],
            PocketFlowPattern.MAPREDUCE: [
                r"large\s*scale\s*processing", r"batch\s*processing", r"parallel",
                r"map\s*reduce", r"distributed", r"big\s*data"
            ],
            PocketFlowPattern.MULTI_AGENT: [
                r"multi\s*agent", r"collaborative", r"coordination",
                r"team\s*work", r"distributed\s*agents", r"agent\s*communication"
            ]
        }
    
    def detect_pattern(self, description: str, requirements: List[str] = None) -> PocketFlowPattern:
        """
        TODO: Implement pattern detection based on feature description and requirements
        
        Args:
            description: Feature description text
            requirements: List of requirement strings
            
        Returns:
            Recommended PocketFlow pattern
        """
        pattern_scores = {pattern: 0 for pattern in PocketFlowPattern}
        
        # Analyze description text
        for pattern, indicators in self.pattern_indicators.items():
            for indicator in indicators:
                if re.search(indicator, description, re.IGNORECASE):
                    pattern_scores[pattern] += 1
        
        # TODO: Analyze requirements file if provided
        if requirements:
            for req in requirements:
                # TODO: Add requirement-based pattern detection
                if "openai" in req.lower() or "anthropic" in req.lower():
                    pattern_scores[PocketFlowPattern.AGENT] += 2
                if "langchain" in req.lower():
                    pattern_scores[PocketFlowPattern.RAG] += 2
        
        # Return pattern with highest score
        return max(pattern_scores, key=pattern_scores.get)
    
    def get_pattern_guidance(self, pattern: PocketFlowPattern) -> Dict[str, Any]:
        """TODO: Customize implementation guidance for each pattern"""
        guidance = {
            PocketFlowPattern.AGENT: {
                "description": "Dynamic decision-making agent with adaptive behavior",
                "key_components": ["Decision Engine", "State Management", "Action Execution"],
                "example_nodes": ["DecisionNode", "ActionNode", "FeedbackNode"],
                "typical_flow": "Input â†’ Analyze â†’ Decide â†’ Execute â†’ Learn"
            },
            PocketFlowPattern.WORKFLOW: {
                "description": "Sequential processing pipeline with defined steps",
                "key_components": ["Input Validation", "Processing Steps", "Output Generation"],
                "example_nodes": ["PrepNode", "ProcessNode", "ValidateNode"],
                "typical_flow": "Input â†’ Prepare â†’ Process â†’ Validate â†’ Output"
            },
            PocketFlowPattern.RAG: {
                "description": "Knowledge-enhanced responses with retrieval augmentation",
                "key_components": ["Document Retrieval", "Context Assembly", "Response Generation"],
                "example_nodes": ["RetrievalNode", "ContextNode", "GenerationNode"],
                "typical_flow": "Query â†’ Retrieve â†’ Augment â†’ Generate â†’ Respond"
            },
            PocketFlowPattern.MAPREDUCE: {
                "description": "Large-scale parallel processing with map-reduce pattern",
                "key_components": ["Data Partitioning", "Parallel Processing", "Result Aggregation"],
                "example_nodes": ["MapNode", "ReduceNode", "AggregateNode"],
                "typical_flow": "Input â†’ Partition â†’ Map â†’ Reduce â†’ Aggregate"
            },
            PocketFlowPattern.MULTI_AGENT: {
                "description": "Collaborative system with multiple coordinating agents",
                "key_components": ["Agent Coordination", "Communication Protocol", "Task Distribution"],
                "example_nodes": ["CoordinatorNode", "AgentNode", "CommunicationNode"],
                "typical_flow": "Coordinate â†’ Distribute â†’ Execute â†’ Communicate â†’ Aggregate"
            }
        }
        return guidance.get(pattern, {})

# TODO: Integrate with your project's template generation
if __name__ == "__main__":
    detector = PatternDetector()
    
    # Example usage - TODO: Replace with your feature description
    example_description = "Build an AI agent that can analyze documents and provide intelligent responses"
    recommended_pattern = detector.detect_pattern(example_description)
    guidance = detector.get_pattern_guidance(recommended_pattern)
    
    print(f"Recommended Pattern: {recommended_pattern.value}")
    print(f"Guidance: {guidance}")
```

## PocketFlow Pattern Templates

### Agent Pattern Template
**Template Output:** Template files for Agent pattern
```python
# src/schemas/[FEATURE_NAME]_agent_schema.py
from pydantic import BaseModel
from typing import Dict, Any, Optional

class AgentInput(BaseModel):
    """TODO: Define agent input schema"""
    query: str
    context: Optional[Dict[str, Any]] = {}
    parameters: Optional[Dict[str, Any]] = {}

class AgentDecision(BaseModel):
    """TODO: Define decision structure"""
    action: str
    confidence: float
    reasoning: str
    parameters: Dict[str, Any]

class AgentOutput(BaseModel):
    """TODO: Define agent output schema"""
    result: Any
    decisions: List[AgentDecision]
    metadata: Dict[str, Any]

# src/nodes/[FEATURE_NAME]_agent_nodes.py  
from pocketflow import Node
from typing import Dict, Any

class DecisionNode(Node):
    """TODO: Implement decision-making logic"""
    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        # TODO: Add your decision-making algorithm
        decision = {
            "action": "placeholder_action",
            "confidence": 0.8,
            "reasoning": "TODO: Add reasoning logic"
        }
        return {"decision": decision, "status": "decided"}

class ActionNode(Node):
    """TODO: Implement action execution logic"""
    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        # TODO: Execute the decided action
        action = input_data.get("decision", {}).get("action")
        result = f"TODO: Execute action: {action}"
        return {"action_result": result, "status": "executed"}
```

### RAG Pattern Template  
**Template Output:** Template files for RAG pattern
```python
# src/schemas/[FEATURE_NAME]_rag_schema.py
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

class RAGQuery(BaseModel):
    """TODO: Define RAG query schema"""
    question: str
    context_limit: Optional[int] = 5
    filters: Optional[Dict[str, Any]] = {}

class RetrievedDocument(BaseModel):
    """TODO: Define document structure"""
    content: str
    score: float
    metadata: Dict[str, Any]

class RAGResponse(BaseModel):
    """TODO: Define RAG response schema"""
    answer: str
    sources: List[RetrievedDocument]
    confidence: float
    metadata: Dict[str, Any]

# src/nodes/[FEATURE_NAME]_rag_nodes.py
from pocketflow import Node
from typing import Dict, Any, List

class RetrievalNode(Node):
    """TODO: Implement document retrieval logic"""
    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        query = input_data.get("question", "")
        # TODO: Implement vector search or keyword retrieval
        retrieved_docs = [
            {
                "content": "TODO: Retrieved document content",
                "score": 0.95,
                "metadata": {"source": "TODO: Document source"}
            }
        ]
        return {"retrieved_docs": retrieved_docs, "status": "retrieved"}

class ContextNode(Node):
    """TODO: Implement context assembly logic"""
    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        docs = input_data.get("retrieved_docs", [])
        # TODO: Assemble context from retrieved documents
        context = "TODO: Assembled context from documents"
        return {"context": context, "status": "context_ready"}

class GenerationNode(Node):
    """TODO: Implement response generation logic"""
    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        context = input_data.get("context", "")
        # TODO: Generate response using LLM with context
        response = "TODO: Generated response based on context"
        return {"generated_response": response, "status": "generated"}
```

### Orchestrator Integration Templates
**Template Output:** `scripts/invoke_llm_orchestrator.sh` for end-user projects
```bash
#!/bin/bash
# LLM/AI Orchestrator Integration Script
# TODO: Customize orchestrator integration for your LLM workflows

invoke_llm_orchestrator() {
    local task="$1"
    local pattern="$2"
    local feature_name="$3"
    
    echo "ðŸ¤– Invoking PocketFlow orchestrator for LLM task: $task"
    echo "ðŸ“‹ Pattern: $pattern"
    echo "ðŸŽ¯ Feature: $feature_name"
    
    case "$task" in
        "detect-pattern")
            claude-code agent invoke pocketflow-orchestrator \
                --task "Analyze feature requirements and recommend PocketFlow pattern" \
                --context "$(pwd)" \
                --feature-description "$(cat docs/requirements.md 2>/dev/null)" \
                --llm-focus "true"
            ;;
        "generate-workflow")
            claude-code agent invoke pocketflow-orchestrator \
                --task "Generate LLM/AI workflow implementation" \
                --context "$(pwd)" \
                --pattern "$pattern" \
                --feature-name "$feature_name" \
                --llm-integration "true"
            ;;
        "validate-llm-workflow")
            claude-code agent invoke pocketflow-orchestrator \
                --task "Validate LLM workflow implementation" \
                --context "$(pwd)" \
                --workflow-file ".agent-os/workflows/${feature_name}.py"
            ;;
    esac
}

# TODO: Add to your project's LLM development workflow
# invoke_llm_orchestrator "detect-pattern" "" "your_feature_name"
```

## Framework Integration Points
This extension enhances the framework's generator.py system to:

1. **Intelligent Pattern Detection**: Analyze feature descriptions and automatically recommend appropriate PocketFlow patterns
2. **Enhanced Template Generation**: Create pattern-specific templates with LLM/AI best practices  
3. **Clear Implementation Guidance**: Provide step-by-step TODO instructions for each pattern
4. **Orchestrator Integration**: Generate seamless integration templates for end-user projects
5. **LLM-Specific Validation**: Include LLM workflow validation templates and examples

### Usage in End-User Projects
When deployed to end-user projects, this extension provides:
- Automatic LLM pattern detection and template selection
- Ready-to-customize PocketFlow implementations for AI features
- Clear TODO guidance for implementing LLM integrations
- Orchestrator integration examples for complex AI workflows
- Validation scripts specifically designed for LLM workflows
