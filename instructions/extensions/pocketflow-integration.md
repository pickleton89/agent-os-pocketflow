# PocketFlow Integration Extension

## Template Generation Guide for Auto-Detection and Orchestration
**Purpose:** Generate comprehensive PocketFlow integration templates that enable automatic pattern detection, seamless orchestration, and flexible project structure support for end-user projects.

## Auto-Detection Templates

### Project Analysis Template
**Template Output:** `scripts/analyze_project_needs.py` for end-user projects
```python
#!/usr/bin/env python3
"""
PocketFlow Integration Auto-Detection
Auto-generated by Agent OS + PocketFlow framework
TODO: Customize detection logic for your project requirements
"""

import os
import re
import yaml
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

@dataclass
class ProjectAnalysis:
    """TODO: Customize project analysis structure"""
    pocketflow_needed: bool
    recommended_patterns: List[str]
    complexity_score: int
    integration_points: List[str]
    suggested_structure: Dict[str, str]

class PocketFlowDetector:
    """TODO: Customize auto-detection algorithms for your project"""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        # TODO: Add custom detection triggers based on your project needs
        self.complexity_triggers = {
            "data_processing": [
                r"batch.*processing", r"data.*pipeline", r"etl", r"transform.*data",
                r"process.*large.*data", r"data.*workflow"
            ],
            "multi_step": [
                r"multi.*step", r"workflow", r"pipeline", r"sequential.*process",
                r"chain.*operation", r"orchestrat"
            ],
            "ai_integration": [
                r"machine.*learning", r"ai", r"llm", r"artificial.*intelligence",
                r"neural.*network", r"deep.*learning"
            ],
            "async_patterns": [
                r"async", r"concurrent", r"parallel", r"background.*task",
                r"queue", r"celery", r"distributed"
            ],
            "microservices": [
                r"microservice", r"service.*mesh", r"api.*gateway",
                r"distributed.*system", r"event.*driven"
            ]
        }
    
    def analyze_project(self) -> ProjectAnalysis:
        """
        TODO: Implement comprehensive project analysis
        
        Returns:
            ProjectAnalysis with recommendations
        """
        complexity_score = 0
        detected_patterns = []
        integration_points = []
        
        # Analyze project files
        complexity_score += self._analyze_requirements()
        complexity_score += self._analyze_code_structure()
        complexity_score += self._analyze_documentation()
        
        # Detect patterns based on complexity
        if complexity_score >= 5:
            detected_patterns.extend(["WORKFLOW", "AGENT"])
        if complexity_score >= 8:
            detected_patterns.append("MULTI-AGENT")
        if complexity_score >= 10:
            detected_patterns.append("MAPREDUCE")
        
        # Suggest project structure
        suggested_structure = self._suggest_project_structure(detected_patterns)
        
        return ProjectAnalysis(
            pocketflow_needed=complexity_score >= 3,
            recommended_patterns=detected_patterns,
            complexity_score=complexity_score,
            integration_points=integration_points,
            suggested_structure=suggested_structure
        )
    
    def _analyze_requirements(self) -> int:
        """TODO: Analyze requirements.txt or pyproject.toml for complexity indicators"""
        score = 0
        req_files = ["requirements.txt", "pyproject.toml", "Pipfile"]
        
        for req_file in req_files:
            req_path = self.project_root / req_file
            if req_path.exists():
                content = req_path.read_text().lower()
                
                # TODO: Add custom dependency analysis
                if any(lib in content for lib in ["fastapi", "django", "flask"]):
                    score += 2
                if any(lib in content for lib in ["celery", "redis", "rabbitmq"]):
                    score += 3
                if any(lib in content for lib in ["openai", "anthropic", "langchain"]):
                    score += 4
                    
        return score
    
    def _analyze_code_structure(self) -> int:
        """TODO: Analyze code structure for complexity patterns"""
        score = 0
        
        # Count Python files
        py_files = list(self.project_root.rglob("*.py"))
        if len(py_files) > 10:
            score += 2
        if len(py_files) > 50:
            score += 3
            
        # TODO: Analyze function complexity, class structures, etc.
        
        return score
    
    def _analyze_documentation(self) -> int:
        """TODO: Analyze documentation for complexity indicators"""
        score = 0
        doc_files = list(self.project_root.rglob("*.md"))
        
        for doc_file in doc_files:
            content = doc_file.read_text().lower()
            for category, patterns in self.complexity_triggers.items():
                for pattern in patterns:
                    if re.search(pattern, content):
                        score += 1
                        
        return score
    
    def _suggest_project_structure(self, patterns: List[str]) -> Dict[str, str]:
        """TODO: Suggest optimal project structure based on detected patterns"""
        base_structure = {
            ".agent-os/workflows/": "PocketFlow workflow definitions",
            "src/schemas/": "Pydantic data models",
            "src/nodes/": "PocketFlow node implementations",
            "src/flows/": "Flow assembly logic",
            "src/utils/": "Utility functions",
            "tests/": "Test implementations",
            "docs/": "Documentation including design.md"
        }
        
        # TODO: Customize structure based on patterns
        if "AGENT" in patterns:
            base_structure["src/agents/"] = "Agent implementations"
        if "RAG" in patterns:
            base_structure["src/retrieval/"] = "Document retrieval logic"
        if "MAPREDUCE" in patterns:
            base_structure["src/mapreduce/"] = "Map-reduce implementations"
            
        return base_structure

# TODO: Integrate with your project setup
if __name__ == "__main__":
    detector = PocketFlowDetector()
    analysis = detector.analyze_project()
    
    print(f"PocketFlow Needed: {analysis.pocketflow_needed}")
    print(f"Complexity Score: {analysis.complexity_score}")
    print(f"Recommended Patterns: {analysis.recommended_patterns}")
    print(f"Suggested Structure:")
    for path, description in analysis.suggested_structure.items():
        print(f"  {path}: {description}")
```

### Orchestration Integration Templates

#### Comprehensive Orchestrator Interface Template
**Template Output:** `scripts/pocketflow_orchestrator.py` for end-user projects
```python
#!/usr/bin/env python3
"""
PocketFlow Orchestrator Integration
Auto-generated by Agent OS + PocketFlow framework
TODO: Customize orchestrator integration for your project workflow
"""

import subprocess
import json
import os
from typing import Dict, Any, List, Optional
from pathlib import Path

class PocketFlowOrchestrator:
    """TODO: Customize orchestrator integration for your project needs"""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        self.context = self._build_context()
    
    def _build_context(self) -> Dict[str, Any]:
        """TODO: Build comprehensive context for orchestrator"""
        return {
            "project_root": str(self.project_root),
            "project_name": self.project_root.name,
            "has_design": (self.project_root / "docs" / "design.md").exists(),
            "requirements": self._get_requirements(),
            "existing_files": self._scan_existing_files()
        }
    
    def _get_requirements(self) -> List[str]:
        """TODO: Extract project requirements"""
        req_file = self.project_root / "requirements.txt"
        if req_file.exists():
            return req_file.read_text().strip().split('\n')
        return []
    
    def _scan_existing_files(self) -> Dict[str, List[str]]:
        """TODO: Scan existing project structure"""
        return {
            "python_files": [str(p) for p in self.project_root.rglob("*.py")],
            "config_files": [str(p) for p in self.project_root.rglob("*.yaml")] +
                           [str(p) for p in self.project_root.rglob("*.yml")] +
                           [str(p) for p in self.project_root.rglob("*.toml")],
            "docs": [str(p) for p in self.project_root.rglob("*.md")]
        }
    
    def invoke_design_creation(self, feature_description: str) -> bool:
        """TODO: Invoke orchestrator for design document creation"""
        try:
            cmd = [
                "claude-code", "agent", "invoke", "pocketflow-orchestrator",
                "--task", "full-lifecycle",
                "--feature", self.context["project_name"],
                "--phase", "design"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root)
            
            if result.returncode == 0:
                print("✅ Design document created successfully")
                return True
            else:
                print(f"❌ Design creation failed: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"❌ Error invoking orchestrator: {e}")
            return False
    
    def invoke_pattern_detection(self, feature_description: str) -> Optional[str]:
        """TODO: Invoke orchestrator for pattern detection"""
        try:
            cmd = [
                "claude-code", "agent", "invoke", "pocketflow-orchestrator",
                "--task", "full-lifecycle",
                "--feature", feature_description[:50],  # Use first 50 chars as feature name
                "--pattern", "auto-detect",
                "--phase", "analysis"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root)
            
            if result.returncode == 0:
                # TODO: Parse orchestrator response to extract pattern
                pattern = result.stdout.strip().split('\n')[-1]
                print(f"✅ Detected pattern: {pattern}")
                return pattern
            else:
                print(f"❌ Pattern detection failed: {result.stderr}")
                return None
                
        except Exception as e:
            print(f"❌ Error in pattern detection: {e}")
            return None
    
    def invoke_workflow_generation(self, feature_name: str, pattern: str) -> bool:
        """TODO: Invoke orchestrator for workflow generation"""
        try:
            cmd = [
                "claude-code", "agent", "invoke", "pocketflow-orchestrator",
                "--task", "full-lifecycle",
                "--feature", feature_name,
                "--pattern", pattern,
                "--phase", "implementation"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root)
            
            if result.returncode == 0:
                print(f"✅ Workflow generated for {feature_name} using {pattern} pattern")
                return True
            else:
                print(f"❌ Workflow generation failed: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"❌ Error in workflow generation: {e}")
            return False
    
    def _get_project_structure(self) -> Dict[str, str]:
        """TODO: Define your project's directory structure preferences"""
        return {
            "workflows": ".agent-os/workflows/",
            "schemas": "src/schemas/" if (self.project_root / "src").exists() else "schemas/",
            "nodes": "src/nodes/" if (self.project_root / "src").exists() else "nodes/",
            "flows": "src/flows/" if (self.project_root / "src").exists() else "flows/",
            "utils": "src/utils/" if (self.project_root / "src").exists() else "utils/",
            "tests": "tests/"
        }
    
    def validate_implementation(self, feature_name: str) -> bool:
        """TODO: Invoke orchestrator for implementation validation"""
        try:
            workflow_file = self.project_root / ".agent-os" / "workflows" / f"{feature_name}.py"
            
            if not workflow_file.exists():
                print(f"❌ Workflow file not found: {workflow_file}")
                return False
            
            cmd = [
                "claude-code", "agent", "invoke", "pocketflow-orchestrator", 
                "--task", "quality-check",
                "--phase", "validation",
                "--scope", f"workflow-{feature_name}"
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root)
            
            if result.returncode == 0:
                print(f"✅ Implementation validation passed for {feature_name}")
                return True
            else:
                print(f"❌ Implementation validation failed: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"❌ Error in validation: {e}")
            return False

# TODO: Integrate with your project development workflow
```

#### Development Workflow Integration Template
**Template Output:** `scripts/pocketflow_workflow.sh` for end-user projects
```bash
#!/bin/bash
# PocketFlow Development Workflow
# Auto-generated by Agent OS + PocketFlow framework
# TODO: Customize workflow for your development process

set -e

# TODO: Configure your project settings
PROJECT_NAME="${PROJECT_NAME:-$(basename $(pwd))}"
POCKETFLOW_ORCHESTRATOR="scripts/pocketflow_orchestrator.py"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}ℹ️ $1${NC}"; }
log_success() { echo -e "${GREEN}✅ $1${NC}"; }
log_warning() { echo -e "${YELLOW}⚠️ $1${NC}"; }
log_error() { echo -e "${RED}❌ $1${NC}"; }

# TODO: Implement feature development workflow
develop_feature() {
    local feature_name="$1"
    local feature_description="$2"
    
    log_info "Starting PocketFlow feature development: $feature_name"
    
    # Step 1: Analyze project needs
    log_info "Step 1: Analyzing project requirements..."
    if ! python scripts/analyze_project_needs.py; then
        log_error "Project analysis failed"
        return 1
    fi
    
    # Step 2: Create/update design document
    log_info "Step 2: Creating design document..."
    if ! claude-code agent invoke pocketflow-orchestrator --task full-lifecycle --feature "$feature_name" --phase design; then
        log_warning "Design creation failed, proceeding with manual design"
    fi
    
    # Step 3: Detect optimal pattern
    log_info "Step 3: Detecting optimal PocketFlow pattern..."
    local pattern
    pattern=$(claude-code agent invoke pocketflow-orchestrator --task full-lifecycle --feature "$feature_name" --pattern auto-detect --phase analysis 2>/dev/null || echo "rag")
    log_info "Selected pattern: $pattern"
    
    # Step 4: Generate workflow implementation
    log_info "Step 4: Generating PocketFlow workflow..."
    if ! claude-code agent invoke pocketflow-orchestrator --task full-lifecycle --feature "$feature_name" --pattern "$pattern" --phase implementation; then
        log_error "Workflow generation failed"
        return 1
    fi
    
    # Step 5: Validate implementation
    log_info "Step 5: Validating implementation..."
    if ! claude-code agent invoke pocketflow-orchestrator --task quality-check --phase validation --scope "workflow-$feature_name"; then
        log_warning "Implementation validation failed, manual review required"
    fi
    
    log_success "Feature development completed: $feature_name"
    log_info "Next steps:"
    log_info "1. Review generated files in .agent-os/workflows/"
    log_info "2. Customize TODO placeholders in generated code"
    log_info "3. Run tests: pytest tests/"
    log_info "4. Update documentation as needed"
}

# TODO: Implement project setup workflow
setup_pocketflow_project() {
    log_info "Setting up PocketFlow integration for $PROJECT_NAME"
    
    # Create directory structure
    log_info "Creating project structure..."
    mkdir -p .agent-os/workflows
    mkdir -p src/{schemas,nodes,flows,utils} || mkdir -p {schemas,nodes,flows,utils}
    mkdir -p tests docs scripts
    
    # Create basic configuration
    log_info "Creating configuration files..."
    
    # TODO: Create project-specific configuration
    cat > .agent-os/pocketflow.yaml << EOF
# PocketFlow Configuration for $PROJECT_NAME
# TODO: Customize configuration for your project

project:
  name: "$PROJECT_NAME"
  patterns: []  # TODO: List preferred patterns
  structure:
    workflows: ".agent-os/workflows/"
    schemas: "src/schemas/"
    nodes: "src/nodes/"
    flows: "src/flows/"
    utils: "src/utils/"
    tests: "tests/"

orchestrator:
  auto_detect: true
  default_pattern: "WORKFLOW"
  validation_level: "strict"  # TODO: Choose: strict, moderate, lenient

# TODO: Add custom settings
EOF

    log_success "PocketFlow project setup completed"
}

# TODO: Add more workflow commands as needed
show_help() {
    echo "PocketFlow Development Workflow"
    echo ""
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "Commands:"
    echo "  setup                           Setup PocketFlow integration"
    echo "  develop <name> <description>    Develop new feature with PocketFlow"
    echo "  validate <name>                 Validate existing workflow"
    echo "  help                           Show this help message"
    echo ""
    echo "TODO: Add custom commands for your workflow"
}

# Command dispatcher
case "$1" in
    "setup")
        setup_pocketflow_project
        ;;
    "develop")
        if [[ -z "$2" || -z "$3" ]]; then
            log_error "Usage: $0 develop <feature_name> <feature_description>"
            exit 1
        fi
        develop_feature "$2" "$3"
        ;;
    "validate")
        if [[ -z "$2" ]]; then
            log_error "Usage: $0 validate <feature_name>"
            exit 1
        fi
        claude-code agent invoke pocketflow-orchestrator --task quality-check --phase validation --scope "workflow-$2"
        ;;
    "help"|"--help"|"-h"|"")
        show_help
        ;;
    *)
        log_error "Unknown command: $1"
        show_help
        exit 1
        ;;
esac
```

## Framework Integration Points
This extension enhances the framework's generator.py system to:

1. **Intelligent Project Analysis**: Automatically detect project complexity and PocketFlow needs
2. **Flexible Structure Generation**: Adapt to different project structures (src/ vs flat, etc.)
3. **Comprehensive Orchestration**: Provide complete workflow integration templates
4. **Development Workflow**: Generate end-to-end development process templates
5. **Validation Integration**: Include comprehensive validation and testing templates

### Usage in End-User Projects
When deployed to end-user projects, this extension provides:

- **Automatic Complexity Detection**: Analyze project needs and recommend PocketFlow integration
- **Flexible Project Structure**: Adapt templates to existing project organization
- **Complete Workflow Integration**: Ready-to-use orchestrator integration with customizable logic
- **Development Process Templates**: Comprehensive workflow for feature development
- **Clear Implementation Guidance**: Step-by-step TODO instructions throughout the process

### Template Deployment Strategy
The framework deploys these templates to end-user projects with:
- **Adaptive Structure**: Templates adjust to existing project organization
- **Clear Customization Points**: All TODO placeholders include specific implementation guidance
- **Modular Components**: Templates can be used independently or together
- **Integration Examples**: Clear examples of orchestrator integration patterns
